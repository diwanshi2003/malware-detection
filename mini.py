import pandas as pd
import tkinter as tk
from tkinter import filedialog, messagebox, simpledialog, ttk
import seaborn as sns
import matplotlib.pyplot as plt
from sklearn.preprocessing import LabelEncoder
from sklearn.model_selection import train_test_split
from sklearn.metrics import classification_report, accuracy_score
from sklearn.svm import SVC
from sklearn.tree import DecisionTreeClassifier
from sklearn.ensemble import RandomForestClassifier
from sklearn.impute import SimpleImputer
from imblearn.over_sampling import SMOTE

class MalwareDetectionApp:
    def __init__(self, root):
        # Initialize the application window
        self.root = root
        self.root.title("Malware Detection")  # Set window title
        self.root.geometry("800x600")  # Set window size

        # Create a style object for consistent UI appearance
        self.style = ttk.Style()

        # Configure style for buttons
        self.style.configure('TButton', font=('Arial', 12), padding=10, background='#333', foreground='black')
        self.style.map('TButton', background=[('active', '#555')])

        # Configure style for labels
        self.style.configure('TLabel', font=('Arial', 14), padding=10, foreground='black')

        # Main Frame with background color
        self.main_frame = ttk.Frame(root, padding=(20, 20, 20, 20), style='Main.TFrame')
        self.main_frame.pack(expand=True, fill='both')

        # Define a custom style for the main frame
        self.style.configure('Main.TFrame', background='#f2f2f2')

        # File Selection
        self.file_label = ttk.Label(self.main_frame, text="Select Dataset:", style='TLabel')
        self.file_label.grid(row=0, column=0, padx=10, pady=10, sticky=tk.W)

        self.file_button = ttk.Button(self.main_frame, text="Browse", command=self.load_file, style='TButton')
        self.file_button.grid(row=0, column=1, padx=10, pady=10, sticky=tk.W)

        # Missing Data Handling
        self.missing_data_button = ttk.Button(self.main_frame, text="Handle Missing Data", command=self.handle_missing_data, state=tk.DISABLED, style='TButton')
        self.missing_data_button.grid(row=1, column=0, padx=10, pady=10, sticky=tk.W)

        # Data Visualization
        self.visualize_button = ttk.Button(self.main_frame, text="Visualize Data", command=self.visualize_data, state=tk.DISABLED, style='TButton')
        self.visualize_button.grid(row=1, column=1, padx=10, pady=10, sticky=tk.W)

        # Model Selection
        self.model_label = ttk.Label(self.main_frame, text="Select Model:", style='TLabel')
        self.model_label.grid(row=2, column=0, padx=10, pady=10, sticky=tk.W)

        self.model_choice = ttk.Combobox(self.main_frame, values=["svm", "dt", "rf", "both", "all"], state=tk.DISABLED, width=10)
        self.model_choice.grid(row=2, column=1, padx=10, pady=10, sticky=tk.W)

        # Run Model Button
        self.run_button = ttk.Button(self.main_frame, text="Run Model", command=self.run_model, state=tk.DISABLED, style='TButton')
        self.run_button.grid(row=3, column=0, columnspan=2, padx=10, pady=10, sticky=tk.W+tk.E)

        # Prediction Section
        self.predict_label = ttk.Label(self.main_frame, text="Predict New Input:", style='TLabel')
        self.predict_label.grid(row=4, column=0, padx=10, pady=10, sticky=tk.W)

        self.predict_button = ttk.Button(self.main_frame, text="Predict", command=self.predict_input, state=tk.DISABLED, style='TButton')
        self.predict_button.grid(row=4, column=1, padx=10, pady=10, sticky=tk.W)

        # Results Display
        self.results_label = ttk.Label(self.main_frame, text="Results:", style='TLabel')
        self.results_label.grid(row=5, column=0, padx=10, pady=10, sticky=tk.W)

        self.results_text = tk.Text(self.main_frame, height=10, width=50)
        self.results_text.grid(row=6, column=0, columnspan=2, padx=10, pady=10, sticky=tk.W)

        # Save Results Button
        self.save_button = ttk.Button(self.main_frame, text="Save Results", command=self.save_results, state=tk.DISABLED, style='TButton')
        self.save_button.grid(row=7, column=0, columnspan=2, padx=10, pady=10, sticky=tk.W+tk.E)

        # Data Attributes
        self.my_data = None  # Placeholder for loaded dataset
        self.svm_model = None  # Placeholder for SVM model
        self.dt_model = None   # Placeholder for Decision Tree model
        self.rf_model = None   # Placeholder for Random Forest model

    def load_file(self):
        # Function to handle file loading
        file_path = filedialog.askopenfilename(filetypes=[("CSV files", "*.csv"), ("All files", "*.*")])
        if file_path:
            self.file_label.config(text=f"Selected file: {file_path}")  # Update UI with file path
            try:
                self.my_data = pd.read_csv(file_path)  # Read CSV into DataFrame
                # Enable buttons after successful file loading
                self.missing_data_button.config(state=tk.NORMAL)
                self.visualize_button.config(state=tk.NORMAL)
                self.model_choice.config(state=tk.NORMAL)
                self.run_button.config(state=tk.NORMAL)
            except Exception as e:
                messagebox.showerror("Error", f"Failed to load file: {e}")  # Show error if file loading fails

    def handle_missing_data(self):
        # Function to handle missing data in loaded dataset
        if self.my_data is not None:
            total_na = self.my_data.isnull().sum().sum()  # Count total missing values
            if total_na > 0:
                action = simpledialog.askstring("Input", "Missing data detected. Choose an action (remove/impute):").strip().lower()
                if action == 'remove':
                    self.my_data = self.my_data.dropna()  # Remove rows with missing values
                elif action == 'impute':
                    imputer = SimpleImputer(strategy='mean')
                    self.my_data = pd.DataFrame(imputer.fit_transform(self.my_data), columns=self.my_data.columns)  # Impute missing values with mean
                else:
                    messagebox.showerror("Error", "Invalid action. No changes made to missing data.")  # Show error for invalid action
            else:
                messagebox.showinfo("Info", "No missing data found.")  # Show info if no missing data

    def visualize_data(self):
        # Function to visualize data using seaborn
        if self.my_data is not None:
            sns.countplot(x='Label', data=self.my_data)  # Count plot of class labels
            plt.title('Distribution of Classification')
            plt.xlabel('Class Label')
            plt.ylabel('Count')
            plt.show()

    def run_model(self):
        # Function to run selected machine learning models
        if self.my_data is not None:
            x = self.my_data.drop(["Label"], axis=1)  # Features
            y = self.my_data['Label']  # Target

            if y.dtype == 'object':
                label_encoder = LabelEncoder()
                y = label_encoder.fit_transform(y)  # Encode categorical labels

            smote = SMOTE(random_state=42)  # Apply SMOTE for class imbalance
            x_resampled, y_resampled = smote.fit_resample(x, y)  # Resample data

            x_train, x_test, y_train, y_test = train_test_split(x_resampled, y_resampled, test_size=0.2, random_state=10)  # Split data

            accuracies = {}  # Initialize accuracies dictionary
            model_choice = self.model_choice.get()  # Get selected model(s)

            try:
                if model_choice in ['svm', 'both', 'all']:
                    kernel = simpledialog.askstring("Input", "Enter kernel type for SVM (linear/poly/rbf):").strip().lower()
                    self.svm_model = SVC(kernel=kernel)  # Initialize SVM model
                    self.svm_model.fit(x_train, y_train)  # Train SVM
                    predictions_svm = self.svm_model.predict(x_test)
                    acc_svm = accuracy_score(predictions_svm, y_test)
                    self.results_text.insert(tk.END, f'SVM Accuracy: {acc_svm}\n{classification_report(y_test, predictions_svm)}\n\n')
                    accuracies['SVM'] = acc_svm  # Store SVM accuracy

                if model_choice in ['dt', 'both', 'all']:
                    max_depth = int(simpledialog.askstring("Input", "Enter max depth for Decision Tree:").strip())
                    self.dt_model = DecisionTreeClassifier(max_depth=max_depth)  # Initialize Decision Tree model
                    self.dt_model.fit(x_train, y_train)  # Train Decision Tree
                    predictions_dt = self.dt_model.predict(x_test)
                    acc_dt = accuracy_score(predictions_dt, y_test)
                    self.results_text.insert(tk.END, f'Decision Tree Accuracy: {acc_dt}\n{classification_report(y_test, predictions_dt)}\n\n')
                    accuracies['Decision Tree'] = acc_dt  # Store Decision Tree accuracy

                    if model_choice == 'both':
                        self.results_text.insert(tk.END, '\n')  # Add newline for clarity

                if model_choice in ['rf', 'both', 'all']:
                    n_estimators = int(simpledialog.askstring("Input", "Enter number of estimators for Random Forest:").strip())
                    self.rf_model = RandomForestClassifier(n_estimators=n_estimators)  # Initialize Random Forest model
                    self.rf_model.fit(x_train, y_train)  # Train Random Forest
                    predictions_rf = self.rf_model.predict(x_test)
                    acc_rf = accuracy_score(predictions_rf, y_test)
                    self.results_text.insert(tk.END, f'Random Forest Accuracy: {acc_rf}\n{classification_report(y_test, predictions_rf)}\n\n')
                    accuracies['Random Forest'] = acc_rf  # Store Random Forest accuracy

                    if model_choice == 'both':
                        self.results_text.insert(tk.END, '\n')  # Add newline for clarity

                # Enable prediction button and save results button after running models
                self.predict_button.config(state=tk.NORMAL)
                self.save_button.config(state=tk.NORMAL)

                # Display accuracies for selected models
                messagebox.showinfo("Info", f"Model(s) trained. Accuracies:\n{accuracies}")

            except Exception as e:
                messagebox.showerror("Error", f"Error during model training: {e}")

    def predict_input(self):
        # Function to predict new input using selected model
        if self.my_data is None:
            messagebox.showwarning("Warning", "No dataset loaded yet.")
            return

        # Example: Assuming new_data has the same structure as your training data
        new_data = pd.DataFrame({
            'ACCESS_ALL_DOWNLOADS': [0, 1],
            'ACCESS_CACHE_FILESYSTEM': [1, 0],
            'ACCESS_CHECKIN_PROPERTIES': [0, 1],
            # Ensure all necessary columns are present
        })

        if new_data.empty:
            messagebox.showwarning("Warning", "No input data provided.")
            return

        # Ensure columns of new_data match those used during training
        expected_columns = set(self.my_data.columns)
        if set(new_data.columns) != expected_columns:
            missing_columns = expected_columns - set(new_data.columns)
            extra_columns = set(new_data.columns) - expected_columns
            messagebox.showerror("Error",
                                 f"Input data columns do not match.\nMissing columns: {missing_columns}\nExtra columns: {extra_columns}")
            return

        try:
            # Assuming new_data preprocessing similar to training data
            # Make predictions using the selected model (example with SVM)
            if self.svm_model is not None:
                predictions_svm = self.svm_model.predict(new_data)
                self.results_text.insert(tk.END, f"SVM Predictions: {predictions_svm}\n")
            else:
                self.results_text.insert(tk.END, "SVM model not trained.\n")

            # Similar steps can be followed for Decision Tree and Random Forest models

        except Exception as e:
            messagebox.showerror("Error", f"Error during prediction: {e}")

    def save_results(self):
        # Function to save results to a file
        if self.results_text.get("1.0", tk.END).strip():
            file_path = filedialog.asksaveasfilename(defaultextension=".txt", filetypes=[("Text files", "*.txt"), ("All files", "*.*")])
            if file_path:
                try:
                    with open(file_path, 'w') as file:
                        file.write(self.results_text.get("1.0", tk.END))  # Write results to file
                    messagebox.showinfo("Info", f"Results saved to {file_path}")
                except Exception as e:
                    messagebox.showerror("Error", f"Error saving results: {e}")
        else:
            messagebox.showwarning("Warning", "No results to save.")

# Initialize tkinter and start the application
if __name__ == "__main__":
    root = tk.Tk()  # Create tkinter root window
    app = MalwareDetectionApp(root)  # Initialize the application
    root.mainloop()  # Start the tkinter event loop






